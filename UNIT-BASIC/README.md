# 테스트의 비밀(Secret of Test)

### 1. 한번 작성된 테스트 코드는 영원히 유지보수 해야 한다.

- 테스트 코드하고자 하는 기능이 변경된다면 테스트 코드도 당연히 수정해야 한다.

### 2. 내부 구현 사항을 테스트하는 것을 피하자.

- 사용자 입장에서 api만을 가지고 테스트 하는 것이지 너무 내부적 상황을 테스트하면 유지보수하기 힘들다.

### 3. 재사용성을 높이기(테스트 유틸리티)

### 4. 배포용 코드와 철저히 분리

### 5. 테스트코드를 통한 문서화

---

# 좋은 테스트의 구조(Structure of Test)

1️⃣ **Before: 테스트 코드가 수행되기 전**

→ beforeEach(각각의 테스트 수행되기 전 호출), beforeAll(딱 한 번 호출)

2️⃣ **a Test**

**→ 준비(Arrange) - 실행(Act) - 검증(Assert)**

**→** **Given(준비 과정을 재사용, 유틸함수) - When(의도적으로 실패하기) - Then(가장 마지막에)**

3️⃣ **After : 테스트 코드가 실행된 이후**

→ afterEach(각각의 테스트마다 호출), afterAll(마무리로 한 번 호출)

---

# FIRST 원칙

### Fast : 느린 것에 대한 의존성 낮추기

### Isolated : 독립적으로, 최소한의 유닛으로 검증하기

### Repeatable : 실행할 때마다 동일한 결과를 유지

### Self-Validating : 스스로 테스트 코드 내에서 결과를 검증하기, CI/CD

### Timely : 시기적절하게 테스트 코드 작성

---

# 테스트의 범위

## Right-BICEP : 모든 요구 사항이 정상 동작 하는지 확인

### Boundary conditions : 모든 코너 케이스에 대해 테스트 하기

- 잘못된 포맷의 인풋, null, 특수문자, 잘못된 이메일, 작은 숫자, 큰 숫자, 중복, 순서가 맞지 않음

### Inverse relationship : 역관계를 적용해서 결과값을 확인

- 일관성을 유지(덧셈 → 뺄셈, 추가 → 제거)

### Cross-check : 다른 수단을 이용해서 결과값이 맞는지 확인

- 추가된 과일 == 전체과일 - 예전의 과일 갯수
- A 알고리즘 == B 알고리즘

### Error conditions : 불행한 경로에 대해 우아하게 처리하는가?

- 네트워크 에러, 메모리 부족, 데이터베이스 중지…

### Performance characteristics : 성능 확인은 테스트를 통해 정확한 수치로 확인

---

# 좋은 테스트의 커버리지

## CORRECT

### Conformance : 특정 포맷을 준수

- 전화번호, 이메일, 아이디, 파일 확장자…

### Ordering : 순서 조건 확인하기

- 순서가 중요한 경우

### Range : 숫자의 범위

- 제한된 범위보다 작거나 큰 경우

### Reference : 외부 의존성 유무, 특정한 조건의 유무

- ~일 때, ~가 되어 있을 때, 어떤 특정한 상황/상태일 때 이런 동작을 한다.

### Existence

- 값이 존재하지 않을 때 어떻게 동작?

### Cardinality : 0-1-N 법칙에 따라 검증

- 하나도 없을 때, 하나만 있을 때, 여러 개가 있을 때

### Time : 상대, 절대, 동시의 일들

- 순서가 맞지 않은 경우, 소비한 시간, 지역 시간
